<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>this in js</title>
</head>
<body>
<script type="text/javascript">
    // 默认绑定
    console.log('普通情况', this)

    function foo() {
        console.log('普通函数体', this)
    }

    foo()

    // this 受函数使用的绑定, 隐式绑定
    function get() {
        console.log(this.a);
    }

    var obj = {
        a: 2,
        get
    }

    obj.get() // 2
    // 在 obj.get 调用下, get 中 this 指向的就是 obj 这个对象
    // 从而得出结论: 如果是谁调用的函数, 那么函数中的 this 就会指向谁

    var obj2 = {
        obj,
        a: 1
    }

    obj2.obj.get() // 2
    // 可以看到,尽管有二层调用, this 指向的还是最近一层中的 this


    // this 丢失的情况
    // 更换调用方式:
    var getIns = obj.get
    getIns() // undefined
    // 可以得出结论 使用 `.` (或者`[]`) 调用的才是具有效用的

    const o1 = {
        text: 'o1',
        fn: function () {
            return this.text
        }
    }
    const o3 = {
        text: 'o3',
        fn: function () {
            console.log('o3', this)
            var fn = o1.fn
            return fn()
        }
    }

    console.log('o3 丢失 this 的情况', o3.fn()) // undefined
    // 尽管 o1.fn 是在 o3 里面调用的, 但是 this 的指向还是丢失了
    // 需要记住的是函数被赋值, this 就会丢失

    // 至于为什么会丢失,这是他的原理: http://www.ruanyifeng.com/blog/2018/06/javascript-this.html


    // 显示绑定:
    // 显示绑定有很多方法: bind/call/apply




    // new 绑定


    // 箭头函数和 this
</script>
<script type="text/javascript" src="strict.js"></script>

</body>
</html>
